# -*- coding: utf-8 -*-

"""
/*************************
programacao_aplicada_IME_grupo_1
                                 A QGIS plugin
 Solução do Grupo 1
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-05-20
        copyright            : (C) 2023 by Grupo 1
        emails               : joao.pereira@ime.eb.br
                               marcio.santos@ime.eb.br
                               pedro.kovalczuk@ime.eb.br
                               vinicius.magalhaes@ime.eb.br
                            
 *************************/

/*************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *************************/
"""
from qgis.core import (QgsProcessing,
                       QgsProcessingAlgorithm,
                       QgsProcessingParameterFeatureSource,
                       QgsProcessingParameterMultipleLayers,
                       QgsProcessingParameterFeatureSink,
                       QgsProcessingParameterNumber, QgsProcessingParameterVectorLayer,
                       QgsProject,
                       QgsField,
                       QgsFeatureSink,
                       QgsCoordinateReferenceSystem,
                       QgsVectorLayer,
                       QgsFields,
                       QgsGeometry,
                       QgsPointXY,
                       QgsFeature,
                       QgsRaster)

from PyQt5.QtCore import QVariant
from qgis.analysis import QgsNativeAlgorithms
from qgis.PyQt.QtCore import QCoreApplication
import processing
from qgis.utils import iface

_author_ = 'Grupo 1'
_date_ = '2023-05-20'
_copyright_ = '(C) 2023 by Grupo 1'

# This will get replaced with a git SHA1 when you do a git archive

_revision_ = '$Format:%H$'


class Projeto3SolucaoComplementar(QgsProcessingAlgorithm):

    INPUT_BUILDINGS = 'INPUT_BUILDINGS'
    INPUT_ROADS = 'INPUT_ROADS'
    DISPLACEMENT_DISTANCE = 'DISPLACEMENT_DISTANCE'
    OUTPUT = 'OUTPUT'

    def initAlgorithm(self, config=None):

        # Inputs
        # Buildings - they will be the focus of cartographic generalization (External iteration).
        self.addParameter(QgsProcessingParameterVectorLayer(self.INPUT_BUILDINGS,
                                                              'BUILDINGS', defaultValue=None))

        # Roads - they will be used to verify if a building is left or right of a road and to move the building according to geometries and styles.
        
        self.addParameter(QgsProcessingParameterVectorLayer(self.INPUT_ROADS,
                                                              'ROADS', defaultValue=None))

        # Displacement distance - it will be used to create the space between buildings and between a single build and the road.
        self.addParameter(QgsProcessingParameterNumber(self.DISPLACEMENT_DISTANCE,
                                                       'DISPLACEMENT DISTANCE',
                                                       type=QgsProcessingParameterNumber.Double,
                                                       defaultValue=10.0))

        # Output - Generalized layer with buildings displaced and rotated.
        self.addParameter(QgsProcessingParameterFeatureSink(self.OUTPUT,
                                                            'GENERALIZED_BUILDINGS'))

    def processAlgorithm(self, parameters, context, feedback):

        # Camada de estradas
        estradas_lyr = self.parameterAsVectorLayer(
                parameters, self.INPUT_ROADS, context)

        # Camada de pontos
        edificacoes_lyr = self.parameterAsVectorLayer(
                parameters, self.INPUT_BUILDINGS, context)

        # Capturar a posicao de cada edificação em uma lista e calcular sua dimensão
        coordenadas_edificacoes = coletar_pontos(edificacoes_lyr)

        # Criar a classe de estrada a partir da camada estrada
        estradas_parametrizadas = Estrada(estradas_lyr)

        # Encontrar o empurrão para cada edificação na estrada e somar ele ao pontor original
        for (i, coord) in enumerate(coordenadas_edificacoes):
            dx, dy = estradas_parametrizadas.calcular_empurrao(coord, 25.0)
            x, y = coord
            coordenadas_edificacoes[i] = Point(x+dx,y+dy)


        # Criar uma nova camada com esses pontos 
        output_lyr = QgsVectorLayer("MultiPoint?crs=EPSG:31982", 'Pontos_Generalizados', 'memory')
        fields = [field for field in edificacoes_lyr.fields()]
        dp = output_lyr.dataProvider()
        dp.addAttributes(fields)
        output_lyr.updateFields()


        # Aplicar a translacao e rotacao para cada feature
        # new_features = []
        for (feature, novas_coordenadas) in zip(edificacoes_lyr.getFeatures(), coordenadas_edificacoes):
            geom = feature.geometry()
            # Coletar cada ponto e gerar um deslocado
            points = []
            for part in geom.asMultiPoint():
                coord = Point(part.x(), part.y())   
                dx, dy = estradas_parametrizadas.calcular_empurrao(coord, 50.0)
                points.append(QgsPointXY(coord.x + dx,coord.y + dy))
            # Gerar a nova geometria 
            new_geom = QgsGeometry.fromMultiPointXY(points)
            feature.setGeometry(new_geom)
            # new_features.append(feature)
            dp.addFeature(feature)
        # dp.updateExtents()
        dp.updateExtents()
        output_lyr.updateExtents()

        # Retornar essa camada
        output_lyr.setRenderer(edificacoes_lyr.renderer().clone())
        output_lyr.triggerRepaint()
        QgsProject.instance().addMapLayer(output_lyr)

    def name(self):
        return 'Solução Complementar do Projeto 3'

    def displayName(self):
        return self.tr(self.name())

    def group(self):
        return self.tr(self.groupId())

    def groupId(self):
        return 'Projeto 3'

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return Projeto3SolucaoComplementar()

###############################################################################
######################## DEFINIÇÃO DA CLASSE ESTRADAS #########################
###############################################################################
from collections import namedtuple
from numpy import sqrt

LineSegment = namedtuple("LineSegment",["beg","end"])
SegmentParameters = namedtuple("SegParams",["u","v","pref","lenght"])
Point = namedtuple("Point", ["x","y"])

def coletar_pontos(layer):
    """
    Coletar as coordenadas dos pontos com as características da camada de 
    edificação.
    """
    coordenates = []
    for feature in layer.getFeatures():
        geom = feature.geometry()
        for part in geom.asMultiPoint():
            coordenates.append(Point(part.x(), part.y()))
    return coordenates


class Estrada():
    def __init__(self, layer) -> None:
        self.segments_params = self.parametrizar_segmentos(layer)

    def parametrizar_segmentos(self,layer:QgsVectorLayer):
        # Assumindo que pegamos uma do tipo
        line_segments = []
        for feature in layer.getFeatures():
            geom = feature.geometry()
            if geom.isMultipart():
                points_list = geom.asMultiPolyline()[0]
                for part in zip(points_list[:-1], points_list[1:]):
                    p0, pf = part
                    x0,y0,xf,yf = p0.x(),p0.y(), pf.x(),pf.y()

                    # Definir o ponto de referência
                    pr = Point(x0, y0)

                    # Calcular os vetores perpendiculares
                    xdif = xf - x0
                    ydif = yf - y0
                    length = sqrt(xdif**2 + ydif**2)
                    u = Point(xdif/length, ydif/length)
                    v = Point(ydif/length, -xdif/length)
                    line_segments.append(SegmentParameters(u,v,pr,length))
        return line_segments


    def calcular_empurrao(self,p:Point, distancia_minima:float):
        x,y = p
        distancia_edific_estrada = 10000.0
        index_trecho = 0

        # Encontrar a estrada que esta mais proxima
        for i, (_,v,(xref,yref),_) in enumerate(self.segments_params):
            vx,vy = v
            dist = abs(vx*(x-xref) + vy*(y-yref))
            if distancia_edific_estrada > dist:
                distancia_edific_estrada = dist
                index_trecho = i

        # Verificar se precisa realizar o empurrão
        if distancia_minima < distancia_edific_estrada:
            return (0.0,0.0)
        else:
            (vx,vy) = self.segments_params[index_trecho].v
            (xref,yref) = self.segments_params[index_trecho].pref
            diferenca_distancia = abs(distancia_minima - distancia_edific_estrada)
            sentido = (vx*(x-xref) + vy*(y-yref))/abs(vx*(x-xref) + vy*(y-yref))
            return (sentido*diferenca_distancia*vx, sentido*diferenca_distancia*vy)

