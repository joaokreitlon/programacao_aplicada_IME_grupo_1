# -*- coding: utf-8 -*-

"""
/*************************
programacao_aplicada_IME_grupo_1
                                 A QGIS plugin
 Solução Complementar do Grupo 1
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-05-06
        copyright            : (C) 2023 by Grupo 1
        emails               : joao.pereira@ime.eb.br
                               marcio.santos@ime.eb.br
                               pedro.kovalczuk@ime.eb.br
                               vinicius.magalhaes@ime.eb.br
                            
 *************************/

/*************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *************************/
"""
from qgis.core import (QgsProcessing,
                       QgsProcessingAlgorithm,
                       QgsProcessingParameterFeatureSource,
                       QgsProcessingParameterMultipleLayers,
                       QgsProcessingParameterFeatureSink,
                       QgsProject,
                       QgsField,
                       QgsFeatureSink,
                       QgsCoordinateReferenceSystem,
                       QgsVectorLayer,
                       QgsFields,
                       QgsGeometry,
                       QgsPointXY,
                       QgsFeature,
                       QgsRaster)

from PyQt5.QtCore import QVariant
from qgis.analysis import QgsNativeAlgorithms
from qgis.PyQt.QtCore import QCoreApplication
import processing
from qgis.utils import iface

_author_ = 'Grupo 1'
_date_ = '2023-05-08'
_copyright_ = '(C) 2023 by Grupo 1'

# This will get replaced with a git SHA1 when you do a git archive

_revision_ = '$Format:%H$'


class Project_2_Complementary(QgsProcessingAlgorithm):

    INPUT_POLYGON = 'INPUT_POLYGON'
    INPUT_MULTILINE = 'INPUT_MULTILINE'
    OUTPUT = 'OUTPUT'

    def initAlgorithm(self, config=None):

        # Inputs
        self.addParameter(QgsProcessingParameterFeatureSource(self.INPUT_MULTILINE,
                                                              'INPUT MULTILINE LAYER', [QgsProcessing.TypeVectorLine], defaultValue=None))

        self.addParameter(QgsProcessingParameterFeatureSource(self.INPUT_POLYGON,
                                                              'INPUT POLYGON LAYER', [QgsProcessing.TypeVectorPolygon], defaultValue=None))

        # Output
        self.addParameter(QgsProcessingParameterFeatureSink(
            self.OUTPUT, 'Output multiline layer'))

    def processAlgorithm(self, parameters, context, feedback):

        # Multiline source
        src_ml = self.parameterAsSource(
            parameters, self.INPUT_MULTILINE, context)

        # Polygon source
        src_poly = self.parameterAsSource(
            parameters, self.INPUT_POLYGON, context)

        # Fields from Multiline source
        ml_fields = src_ml.fields()

        # Add boolean that specifies if is inside a polygon or not
        ml_fields.append(QgsField('dentro_de_poligono', QVariant.Bool))

        # Output specifications
        (sink, dest_id) = self.parameterAsSink(parameters, self.OUTPUT, context,
                                               ml_fields, src_ml.wkbType(),
                                               src_ml.sourceCrs())

        # Feature variables
        total_features = src_ml.featureCount()
        ml_features = src_ml.getFeatures()
        poly_features = src_poly.getFeatures()
        processed_features = 0

        # Loop to verify, for each feature in Multiline,
        # if its geometry is within the geometry from Polygon.
        for ml_feature in ml_features:
            geometry_ml = ml_feature.geometry()
            within = False
            for poly_feature in poly_features:
                geometry_poly = poly_feature.geometry()
                if geometry_ml.within(geometry_poly):
                    within = True
                    break

            # Add feature in sink
            ml_feature.setAttributes(ml_feature.attributes() + [within])
            sink.addFeature(ml_feature)

            # Set the feedback for processed features
            processed_features += 1
            feedback.setProgress(100.0 * processed_features / total_features)

        return {self.OUTPUT: dest_id}

    def name(self):
        return 'Solução Complementar do Projeto 2'

    def displayName(self):
        return self.tr(self.name())

    def group(self):
        return self.tr(self.groupId())

    def groupId(self):
        return 'Projeto 2'

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return Project_2_Complementary()
